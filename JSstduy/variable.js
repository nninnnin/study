var str = 'string'; //str은 string 총 6글자이고 따라서 length는 6
let result = '';

//문자열은 유사배열이다!!

for(let i=0;i<str.length;i++){//i가 str.legnth(=6)보다 작을때 즉 index 0부터 5까지 looping
    result += str[i]//유사배열이므로 가능하다
    console.log(result);
} 

//문자열을 변경할 수 없다
str[0] = 'p';
console.log(`string은 ptring으로 바뀔것인가? 결과 : ${str}`);



//그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라, 새로운 문자열을 새롭게 할당하는 것이기 때문이다. (즉, 여전히 immutable하다. 새로운 문자열을 만들고 이 새로운 문자열에 해당하는 주소로 변수의 참조값을 바꿔주는 것이기 때문이다.)

let foo = true;
console.log(typeof foo);

//비어있는 문자열과 null, undefined, 숫자 0은 false로 간주한다!!


//undefined타입의 값은 undefined가 유일하다. 선언 이후 값을 할당하지 않은 변수는 undefined값을 가진다. 즉, 선언 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 반환된다. 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기값, garbage value가 들어있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다.

let food;
console.log(food);

//이처럼 undefined는 의도적으로 할당된 값이 아니라, 자바스크립트 엔진에 의해 초기화된 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는 변수라는 것을 개발자는 간파할 수 있다.

//그렇다면 의도적으로 undefined를 할당해야 하는 경우가 있는가? 자바스크립트 엔진이 변수 초기화에 사용하는 이 값을 만약 개발자가 마음대로 할당한다면 위에서 설명한 undefined의 본 취지와 어긋나므로 권장되지 않는다. 만약 의도적으로 'undefined'한 값을 할당하고 싶다면 null을 할당하는 것이 보통이다.


//null타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로, null은 Null, NULL과 !!!다르다!!!

//프로그래밍언어에서 null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다.

//이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미!!하며 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것이다.

//함수가 호출되었으나 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반영한다.

// let element = document.querySelector('.myElem');
// console.log(element);//물론 여기선 실행이 안되지...브라우저에서


console.log(typeof null);//null의 type은 null이 아닌 object로 나오는데, 설계상의 실수라고 한다.
//따라서 null 타입을 확인할 때 typeof연산자를 사용하면 안되며, 일치 연산자(===)를 사용해야 한다

let fol =null;
console.log(typeof fol === null);
console.log(fol === null);


//symbol은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 변경 불가능한 원시 타입의 값. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티키를 만들기 위해 사용된다. 심볼은 Symbol 함수를 호출해 생성한다. 


let key = Symbol('key');
console.log(typeof key);

let obj ={};
obj[key] = 'value';
console.log(obj[key]);


//객체 타입(Object type, reference type. 참조타입.)
//객체는 데이터와 그 데이터에 관련한 동작을 모두 포함할 수 있는 개념적 존재이다.

//자바스크립트는 객체기반의 스크립트 언어로서, 자바스크립트를 이루고 있는 거의 모든것이 객체이다. 원시타입을 제외한 나머지값을, 배열, 함수, 정규표현식 등은 모두 객체이다!!!!!!!

//객체는 pass-by-reference(참조에 의한 전달) 방식으로 전달된다.

//변수는 var, let, const 키워드를 사용하여 선언하고 할당 연산자를 사용해 값을 할당한다.


//할당 연산자...는 도대체 무엇인가. 바로 '='을 말한다..^^;어이가 없다

//데이터는 메모리에 저장되어있다. 메모리에 저장된 데이터를 참조하려면 데이터가 저장된 메모리 상의 주소를 알아야한다. (address) 식별자는 데이터가 저장된 메모리 상의 주소를 기억한다.

//변수명은 식별자로 불리기도 하며 명명규칙이 존재한다.
//반드시 영문자, underscore 또는 $(달러기호)로 시작하여야 한다.
//자바스크립트는 대-소문자를 구분한다<!DOCTYPE html>

//선언만 되어있는 변수는 undefined를 갖는다.
//선언하지않은 변수에 접근하면 ReferenceError가 발생한다.

var x;
console.log(x);//undefiend
// console.log(y);//ReferenceError


//모든 선언문은 호이스팅된다. var,let,const,function,function*,class

//변수는 3단계에 걸쳐 생성된다.
//1. 선언단계 (Declaration Phase)
//변수객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 변수 객체<!DOCTYPE html>

//2. 초기화단계 (Initialization Phase)
//변수객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.

//3. 할당단계(Assignment Phase)
//undefined로 초기화된 변수에 실제값을 할당한다.


//var 키워드로 선언된 변수는 선언단계와 초기화단계가 한번에 이루어진다.
//즉 스코프에 변수가 등록되고 - 변수는 메모리에 공간을 확보한 후 - undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object(변수객체)에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라고 한다.

//이후 변수 할당문에 도달하면 비로소 값의 할당이 이루어진다.

console.log(foo);// 1) undefined. 변수 호이스팅 덕분에 ReferenceError가 아니라 변수 선언과 undefined로의 초기화가 이루어진 foo를 만나게 되어 undefined를 출력한다. let으로 선언했으면 안되겠지?

var foo2 = 123;//여기에서 값 할당

console.log(foo2);// 2) 123. 할당된 값이 출력

{
    var foo2 = 456; //블록레벨이 아니기 때문에,
}

console.log(foo2);// 3)여기에서 호출해도(다른 블록레벨이지만 함수레벨은 같으므로) 456 이 출력된다. 자바스크립트의 변수는 블록레벨스코프가 아닌 함수레벨스코프를 갖는다. 단 ES6의 let,const를 사용하면 블록레벨 스코프를 사용할 수 있다!


//console.log(letVar);//letVar는 let으로 선언했으므로 오류가난다.
//let으로 선언하면 호이스팅이라는 개념이 없어지는 것
let letVar = 12345;


//var 키워드로 선언된 변수의 문젯점!

//ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다.

//1. 함수 레벨 스코프 - 전역변수의 남발, for loop 초기화시작에서 사용한 변수를 for loop외부 또는 전역에서 참조할 수 있다
//2. var 키워드 생략 허용 - 의도하지 않은 변수의 전역화 위험성
//3. 중복 선언 허용 - 의도하지 않은 변수값 변경의 위험성
//4. 변수 호이스팅 - 변수를 선언하기 전에 참조가 가능하다

//대부분의 문제는 전역변수로 인해 발생한다. 전역변수는 간단한 애플리케이션의 경우, 사용이 편리한 면이 있지만 불가피한 상황을 제외하고 사용을 억제해야한다. 전역변수는 유효범위(Scope)가 넓어서 어디에서 어떻게 사용될지 파악하기가 힘든 특징이 있고, 이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 높다는 것을 의미한다. 또한 여러 함수와 상호 의존하는 등 부수효과(side effec)가 있을 수 있어서 프로그래밍의 복잡성이 증가한다.

//변수의 유효범위 (scope)는 좁을수록 좋다!


