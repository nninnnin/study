//스코프, Scope, 유효범위

//자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념으로, 확실한 이해가 필요

var x = 'global';

function foo(){
    var x = 'function scope';
    console.log(x);
}

foo();
console.log(x);

//스코프는 참조대상식별자 (identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다.

//프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리할 수 있다. 변수는 전역 또는 코드 블록이나 함수 내에 선언하며 함수는 중첩될 수 있다. 식별자는 ''자신이 어디에서 선언되었는지에 의해'' 그 유효한 범위를 갖는다.

//바로 그 유효범위, 가 스코프

//위 예제에서 전역에 선언된 변수 x는 어디에서든 참조할 수 있다. 하지만 함수 foo내에서 선언된 변수 x는 해당 함수 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다. 이러한 규칙을 스코프라고 한다.

//만약 스코프가 없다면 어떻게될까? 스코프가 없다면 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다. 
console.log('----------');

var global = 'global';

function foo2(){
    var local = 'local';
    console.log(global);
    console.log(local);
}

foo2();
console.log(global);
// console.log(local); //Uncaught ReferenceError: local is not defined

//전역변수의 사용은 변수 이름이 중복될 수 있고, 의도치않은 재할당에 의한 상태변화로 코드를 예측하기 어렵게 만들기 때문에 사용을 지양하여야 한다.

console.log('-------------------');

var x2 = 'global'

function foo3(){
    var x2 = 'local';
    console.log(x2); //local 이겠죠?

    function bar(){
        console.log(x2);//?아마 얘는 local일 것 같고
    }

    bar();
}

foo3();
console.log(x2);//? 아마 얘는..그냥 global이 아닐까

//다 맞혔네요^^

//내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다.
//내부함수 bar에서 참조하는 변수 x는 외부함수 foo에서 선언된 지역변수이다.
//이는 실행 컨텍스트의 스코프 체인에 의해 참조 순위에서 전역변수 x가 뒤로 밀렸기 때문이다.

console.log('------------');

var x4 = 10;

function foo4() {
  x4 = 100; //얘는 이 안에서 새롭게 선언된 x4가 아니라 전역에서 선언되어 10이 할당된 x4를 참조한다는 것을 의미한다..따라서 전역변수 x4에다가 100을 새롭게 할당해버리는거다. 만약 여기에서 새롭게 var x4=100;을 했으면 바깥에서는 10이 나오지 않을까? 해보니까 그렇다!
  //var로 선언하는 변수의 함수범위 스코프가 요런 단점이 있다는거다. 헷갈리고, 나도 모르는 사이에 바뀌어버릴 수 있으니까.
  console.log(x4);
}
foo4();
console.log(x4); // ? 얘가 100이 나온다니. 10일거라고 생각했는데..바뀐 그대로다.

//내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다..!


console.log('---------');
var x5 = 10;

function foo5(){
    var x5 = 100; //여기서 x5는 새롭게 생성된, 전역변수 x5와는 구분되는 foo5의 지역변수겠죠
    console.log(x5);//따라서 얘는 100을 출력할거고

    function bar(){
        x5 = 1000;//과연 얘가 foo5의 x5를 참조해서 1000을 할당할 것인지, 아니면 전역의 x5를 참조할 것인지.
        console.log(x5); //당연히 1000을 출력할테지만 어떤 것을 참조했는지는 모른다
    }

    bar();
}

foo5();
console.log(x5); //? 전역변수 x5를 출력해봄으로서 bar안에서 어떤 x5를 참조해서 새롭게 1000을 할당했는지 알 수 있다.

//결과적으로 마지막 console.log에서 출력한 전역변수 x5가 10의 값을 가지고 있었으므로, bar에서는 가장 가까운 곳에 있는 x5, 즉 외부함수 foo5의 지역변수 x5를 참조했음을 알 수 있다.

//한마디로 정의하면 중첩 스코프는 가장 인접한 지역을 우선하여 참조한다.

var foo6 = function(){
    var a=3, b=5;

    var bar2 = function(){
        var b=7, c=11;

        //이 시점에서 a는 3, b는 7, c는 11이다
        a += b+c; //바깥에 있는 a를 참조해서 3에다가 7,11을 더해주었다
        //이 시점에서 a는 21, b는 7, c는 11
    };
    //이 시점에서 a는3, b는 5, c는 not defined
        bar2();
    //이 시점에서 a는 bar2에서 참조되어 21로 바뀌었고, b는 5
};


//렉시컬 스코프
//아래 예제의 실행 결과는 어떤지 생각해보자

var x6 = 1;
function foo6(){
    var x6 = 10;//얘는 전역 x6을 참조한것이 아니라 지역변수 x6을 새로 선언해서 10을 할당한 것
    bar3();//이 bar는 foo에서 호출되었으며,
}

function bar3(){//선언은 전역에서 되었으며
    console.log(x6);
}

foo6(); //?
bar3(); //이 bar는 전역에서 호출되었다.


//위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 

//두가지 패턴을 예측할 수 있는데,
//첫번째는 함수를 어디에서 ***호출***하였는지에 따라 상위 스코프를 결정하는 것이고 - 

//두번째는 함수를 어디에서 ***선언***하였는지에 따라 상위 스코프를 결정하는 것이다. - 

//첫번째 방식(함수 호출기준)으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식(선언기준)으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.

//두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.








