# 8장. 함수
이 장에서는 함수를 정의하는 방법과 인수에 관한 기본적인 지식, 재귀 함수와 클로저, 고차함수, ECMA6부터 추가된 기능 등 함수와 관련된 자세한 내용을 배웁니다. 함수는 자바스크립트라는 프로그래밍 언어를 규정하는 가장 중요한 구성 요소입니다. 특히 자바스크립트에서는 함수가 일급 객체이며 함수로 클로저를 정의할 수 있다는 장점이 있습니다. 그만큼 자바스크립트는 알고리즘을 표현하기 위한 강력한 수단을 가지고 있습니다!

함수를 정의하는 방법과 중첩함수에 대해 짧게 알아보겠습니다. 함수 안에 선언한 함수인 중첩함수는 8.6절에서 설명하는 클로저를 이해하는데 중요한 역할을 합니다.

## 1. 함수 정의하기
함수를 정의하는 방법

함수를 정의하는 방법은 **네가지**입니다.

1. 함수 선언문으로 정의하는 방법

```js
function square(x){return x*x;}
```

2. 함수 리터럴로 정의하는 방법

```js
var square = function(x){return x*x};
```
3. Function 생성자로 정의하는 방법

```js
var square = new Function("x", "return x*x");
```
4. 화살표 함수 표현식으로 정의하는 방법
```js
var square = (x)=>{x*x};
```



함수 리터럴, Function생성자, 화살표 함수 표현식으로 정의한 함수는 변수에 그 함수의 참조를 할당해야 비로소 사용할 수 있는 상태가 됩니다. 따라서 이 세가지 방법으로 함수를 정의하는 코드는 호출하는 코드보다 앞에 위치해야 합니다. (호이스팅 X. 호이스팅은 함수선언문만.)

중첩함수

<hr>

## 2. 함수 호출하기

### 함수를 호출하는 방법
1) 함수 호출 : 함수의 참조가 저장된 변수 뒤에 그룹 연산자인 ()을 부텨엇 함수를 호출합니다.
2) 메서드 호출 : 함수호출과 본질적으로 같습니다.
3) 생성자 호출 : 함수의 참조를 저장한 변수 앞에 new 키워드를 추가하면 함수가 생성자로 동작합니다. 생성자는 9장에서 더 자세히 배웁니다.
4) call, apply를 사용한 간접 호출 ** : 함수의 call과 apply 메서드를 사용하면 함수를 '간접적으로 호출' 할 수 있습니다. 이 방법도 9장에서 자세하게 배웁니다.
### 즉시 실행 함수
일반적으로 익명 함수를 실행할 때에는 익명 함수의 참조를 변수에 할당한 후에 그룹 연산자인 ()를 붙여서 실행합니다
```js
var f = function(){...};
f();
```
자바스크립트는 익명 함수를 정의하고 곧바로 실행하는 '즉시 실행 함수' 라는 구문이 있습니다. 앞의 예를 즉시 실행 함수로 수정하면 다음과 같아집니다.
```js
(function(){...})();
//또는
(function(){...}());
```

즉시 실행 함수에도 이름을 붙일 수 있지만 함수 이름이 함수 내부에서만 유효합니다.
```js
(function fact(n){
    if(n<=1){return 1};
    return n*fact(n-1);
})(5);//5를 인수로 넘겨 함수 fact(n)를 실행
```
즉시 실행 함수는 **전역 유효 범위를 오염시키지 않는 이름 공간을 생성할 때 사용**합니다. 이에 관해 더 자세히는 뒤에 나옵니다!

## 3. 함수의 인수

자바스크립트에서는 함수를 호출할 때 인수를 생략하거나 함수 정의식에 작성된 인자의 갯수보다 더 많은 갯수의 인수를 넘겨서 함수를 실행할 수 있는데, 이러한 상황에서 함수가 어떻게 작동하는지 알아봅니다.

### 인수의 생략
함수 정의식에 작성된 인자 갯수보다 인수를 적게 전달해서 함수를 실행하면 인수에서 생략한 인자는 undefined가 됩니다.

```js
function f(x,y){
    console.log(`x=${x} y=${y}`);
}
f(2); // x=2, y=undefined
```

인수가 생략되었을 때의 기본값을 설정할 수도 있습니다! (논리합연산자 || 사용)
```js
function multiply(a,b){
    b = b || 1; // 논리합연산자 || 의 왼쪽이 true일 때는 왼쪽 값을 그대로 return, false일 때는 오른쪽 값을 return. 따라서 b가 undefined일 때에는 false로 간주하여 논리합연산자 ||의 오른쪽에 있는 값 1을 변수 b에 대입한다. 초깃값을 1로 설정한 것이다.
}
multiply(2); //a에 대입한 2와 b에 기본값으로 대입된 1이 곱해져 2가 나오게 된다.
```

### 가변길이 인수 목록(Arguments 객체)
모든 함수에서 사용할 수 있는 지역 변수로는 arguments 변수가 있습니다. **arguments 변수의 값은 Arguments 객체입니다.** 함수에 인수를 n개 넘겨서 호출하면 인수 값이 다음과 같이 arguments에 저장됩니다.

arguments[0]: 첫번째 인수 값
arguments[1]: 두번째 인수 값
...
arguments[n-1]: n번째 인수 값

Arguments객체는 프로퍼티로 length와 callee를 갖고 있으며 각 프로퍼티에는 다음과 같은 값이 담겨 있습니다. 

argument.length : 인수의 갯수
arguments.callee : 현재 실행되고 있는 함수의 참조

이 Arguments 객체는 **'유사배열객체'** 입니다! 유사 배열 객체에 관한 설명은 10.3절에서 자세히 나옵니다!

arguments[i] 값을 바꾸면 i+1번째 인자가 있을 때 그 값이 함께 바뀝니다.

```js
function f(x,y){
    arguments[1] = 3;
    console.log(`x=${x} y=${y}`)
}
f(1,2); //x=1,y=3

//arguments[1]의 값을 바꾸면 함수의 인자 y의 값이 함께 바뀝니다. 일반적인 배열에는 이러한 성질이 없습니다.
```

arguments 변수를 활용하면 인수 개수가 일정하지 않은 가변 인수 함수를 정의할 수 있습니다.

예를 들어보면..

다음 myConcat 함수는 첫 번째 인수로 받은 separator로 두 번째 이후의 모든 인수를 연결한 문자열 하나를 반환합니다.

```js
function myConcat(separator){
    var s = "";
    for(var i=1; i<arguments.length; i++){ //두번째 인수부터 돌아야하니까 i=1이고, length보다 하나 작게 돌아야 두번째~끝까지 도니까 <=이 아니라 <가 맞다.
        s+=arguments[i]; //argument의 i번째 인수를 s에 넣어주고
        if(i<arguments.length-1) s+= separator; //첫번째 인수로 받은 seperator "/"를 그 다음에 넣어주는데, 반복을 도는 마지막 인수의 뒤에는 안넣어주어야 하니까 length-1 이라는 조건을 추가해주었다.
    }
    return s;
}
console.log(myConcat("/","apple","orange","peach","donggyu"));
```

arguments는 유사 배열 객체입니다. 하지만 다음과 같은 방법을 사용하면 배열 객체로 변환할 수 있습니다.
```js
var params = [].slice.call(arguments);
```
slice는 배열의 method이며 10장에서 설명하고, call메서드를 사용한 메서드의 호출방법은 살짝 뒤에서 나옵니다!


## 4. 재귀함수
함수가 자기 자신을 호출하는 행위를 가리켜 재귀 호출, recursive call 이라고 합니다. 이러한 재귀 호출을 수행하는 함수를 재귀 함수라고 합니다.
### 재귀함수의 기본
```js
function fact(n){
    if(n<=1){return 1;}
    return n*fact(n-1);
}
fact(5);
```
argument.callee를 사용하면 이름이 없는 익명 함수도 재귀 호출을 할 수 있습니다. arguments.callee가 지금 실행 중인 함수를 가리키기 때문입니다.
```js
var fact = function(n){
    if(n<=1) return 1;
    return n*arguments.callee(n-1);
}
```

*재귀함수를 정의할 때에는 다음 두가지 사항에 유의해야 합니다!*
1. 재귀 호출은 반드시 멈춰야 한다.
2. 재귀 호출로 문제를 간단하게 해결할 수 있을 때에만 사용한다.

### 재귀함수의 예
재귀 호출을 유용하게 활용할 수 있는 예를 몇가지 살펴봅시다.
```js
/*
    !!!하노이의 탑!!!

    받침대 위에 막대기 A,B,C가 세워져 있습니다. 막대기 A 가운데에는 구멍이 뚫린 크기가 다른 원반이 여러 장 꿰어져 있습니다. 원반 크기는 아래로 갈수록 커집니다. 이 때 원반을 다음 규칙에 따라 막대기 A에서 막대기 C로 옮깁니다.

    - 원반은 한 번에 한개만 옮길 수 있다.
    - 원반은 막대기 A,B,C 이외의 장소에는 놓을 수 없다.
    - 원반을 옮길 때는 작은 원반 위에 그보다 큰 원반을 쌓을 수 없다.

    이제 막대기 A에 있는 원반 n개를 막대기 B를 경유하여 막대기 C로 이동시키는 방법을 구현한 함수인 hanoi(n,a,b,c)를 만들어 보겠습니다.

    이 함수의 인수 (a,b,c)의 값은 "A","B","C" 중 하나입니다. 또한 가장 위에 놓인 원반을 첫 번째 원반이라고 하고 그 아래에 깔린 나머지 원반에도 쌓인 순서대로 번호를 매깁니다. 이 때 n-1개의 원반을 특정 막대기에서 다른 막대기로 옮기는 방법을 알고 있다면 원반 n개를 막대기 A에서 막대기 C로 옮기는 방법을 다음과 같이 정의할 수 있습니다.

    1) 막대기 A의 가장 아래에 깔린 원반(n번째 원반)을 제외한 나머지 n-1개 원반을 막대기 C를 거쳐 막대기 B로 옮긴다. (그러면 그 케이크 모양 그대로 B로 옮겨지게 됨)
    2) 막대기 A의 가장 아래에 깔린 원반(n번째 원반)을 막대기 C로 옮긴다.
    3) 막대기 B에 있는 나머지 n-1개 원반을 막대기 A를 거쳐 막대기 C로 옮긴다.
    
    A에 있던 케이크가 C에서 완성된다!

    이를 프로그램으로 작성하면..
*/

function hanoi(n,a,b,c){
    if(n<1){return;}
    hanoi(n-1,a,c,b);
    console.log(`${n}번째 원반: ${a}->${c}`);
    hanoi(n-1,b,a,c);
}
hanoi(4,"A","B","C");

```

퀵소트(quick sort)
퀵 정렬을 수행하는 함수. a[0],a[1], ... , a[n-1]을 오름차순(작은것에서 큰것)으로 정렬하는 알고리즘이다. 평균 실행 시간이 O(nlogn)으로 가장 빠른 정렬 알고리즘 중 하나이다.

퀵 정렬 알고리즘은 다음과 같다!
1) 적당한 값 p를 고른다. p를 고를 때는 가능한 그 값의 크기가 p값 이상인 요소의 개수와 p값 이하인 요소의 개수가 같도록 한다.
2) 배열 앞부분에는 p값 이상인 요소를 옮기고, 배열 뒷부분에는 p 값 이하인 요소를 옮긴다.
3) 배열 앞부분의 길이가 2 이상이면 그 부분을 대상으로 퀵 정렬을 한다.
4) 배열 뒷부분의 길이가 2 이상이면 그 부분을 대상으로 퀵 정렬을 한다.

이처럼 퀵 정렬은 배열을 두개로 나눈 후에 나눈 부분을 대상으로 퀵 정렬을 재귀적으로 반복한다!

```js
/*
    퀵정렬
    x : 정렬할 배열
    first : 정렬할 첫번째 요소의 위치
    last : 정렬할 마지막 요소의 위치
*/
function quicksort(x,first,last){
    var p = x[Math.floor((first+last)/2)]; //최대한 중간값을 찾아서 p에 넣고
    for(var i = first, j = last; ; i++,j--){//for문 안에 while문이라니..일단 i와 j값을 받아오겠죠?
        while(x[i]<p) i++; //x[i]가 p보다 작다면 i++하고 (크다면 ++하지 않고 멈추겠죠.)
        while(p<x[j]) j--;//반대로 x[j]가 p보다 크다면 j-- (작다면 --하지 않고 멈추겠죠?) 
        if(i>=j) break;//i가 j보다 커지는 시점에서 중단!
        var w = x[i]; x[i]=x[j]; x[j]=w;
    }
    if(first<i-1) quicksort(x,first,i-1);
    if(j+1<last) quicksort(x,j+1,last);
}
var a = [7,2,5,1,8,9,3]
quicksort(a,0,a.length-1);//배열,first,last
console.log(a);

```

## 5. 프로그램의 평가와 실행 과정
이 절에서는 자바스크립트 프로그램을 평가하는 과정과 실행하는 과정을 설명합니다. 자바스크립트의 내부 작동 구조를 설명하고,이 내용은 다음 절에서 배울 클로저를 이해하기 위한 준비 과정이기도 합니다.
### 실행가능한 코드
자바스크립트 엔진은 Executable code를 만나면 그 코드를 평가(Evaluation)해서 실행 문맥(Execution Context)으로 만듭니다. 이 실행 가능한 코드(Executable Code)의 유형은 다음과 같습니다.
- 전역 코드
- 함수 코드
- eval 코드

전역코드는 전역 객체 Window 아래에 정의된 함수를 말하고, 함수 코드는 문자 그대로 함수를 말하며, eval 코드는 eval 함수를 말합니다.

자바스크립트 엔진이 실행 가능한 코드의 유형을 분류하는 이유는 실행 문맥을 초기화하는 환경과 과정이 다르기 때문입니다. 특히 eval 코드는 앞으로 설명할 렉시컬 환경이 아니라 별도의 동적 환경에서 실행됩니다. 따라서 이 책에서는 eval의 실행 문맥에 관한 설명을 제외합니다.

###실행 문맥의 구성 (context!!)
실행 문맥, Execution Context는 실행 가능한코드가 실제로 실행되고 관리되는 영역으로 실행에 필요한 모든 정보를 컴포넌트 여러개가 나누어 관리하도록 만들어져 있습니다.

그 중에서 가장 중요한 컴포넌트는 

- 렉시컬 환경 컴포넌트,
- 변수 환경 컴포넌트,
- 디스 바인딩(This binding)컴포넌트

입니다. 다음 코드는 자바스크립트의 객체 표현을 빌려 실행 문맥을 표현한 것입니다. 자바스크립트의 객체 표현을 빌린 의사(Pseudo) 코드라 실행할 수 없습니다.

```js
ExecutionContext={
    //렉시컬 환경 컴포넌트
    LexicalEnvironment:{},
    //변수 환경 컴포넌트
    VariableEnvironment:{},
    //This binding 컴포넌트
    ThisBinding: null,
}
```

**렉시컬 환경 컴포넌트와 변수 환경 컴포넌트**

렉시컬 환경컴포넌트와 변수환경 컴포넌트는 앞으로 설명할 렉시컬 환경 타입의 컴포넌트 입니다. 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 타입이 같고 실제로 with문을 사용할 때를 제외하면 내부 값이 같으므로 똑같이 취급해도 무리가 없습니다. 따라서 이후부터는 렉시컬 환경 컴포넌트로 통일해서 설명합니다.

**디스 바인딩 컴포넌트**

This Binding 컴포넌트는 그 함수를 호출한 객체의 참조가 저장되는 곳입니다. 이것이 가리키는 값이 곧 해당 실행 문맥의 this 가 됩니다.

###렉시컬 환경 컴포넌트의 구성

실행 Context의 구성 요소인 LexicalEnvironment Component는 자바스크립트 엔진이 자바스크립트 코드를 실행하기 위해 자원(resource)를 모아 둔 곳으로, 구체적으로는 함수 또는 블록의 유효범위 안에 있는 식별자와 그 결과값이 저장되는 곳입니다. 

자바스크립트 엔진은 해당 자바스크립트 코드의 유효범위(Scope)안에 있는 식별자와 그 식별자가 가리키는 값을 키와 값의 쌍으로 바인드해서 렉시컬 환경 컴포넌트에 기록합니다.

렉시컬 환경 컴포넌트는 환경레코드(Environment Record)와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 컴포넌트로 구성되어 있습니다. 다음 코드는 자바스크립트의 객체 표현을 빌린 의사 코드로 렉시컬 환경 컴포넌트를 표현한 것입니다.

```js
ExecutionContext ={
    LexicalEnvironment:{},
    VariableEnvironment:{},
    ThisBinding:null
}
```

### 렉시컬 환경 컴포넌트의 구성

LexicalEnvironment 컴포넌트는 자바스크립트 엔진이 자바스크립트 코드를 실행하기 위해 자원을 모아 둔 곳으로 구체적으로는 함수 또는 블록의 유효 범위(Scope) 안에 있는 식별자와 그 결괏값이 저장되는 곳입니다. 

자바스크립트 엔진은 해당 자바스크립트 코드의 유효범위(Scope) 안에 있는 **식별자와 그 식별자가 가리키는 값**을 **키와 값의 쌍으로 바인드**해서 **렉시컬 환경 컴포넌트에 기록**합니다.

렉시컬 환경 컴포넌트는 환경레코드(Environment Record)와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 컴포넌트로 구성되어 있습니다.

```js
LexicalEnvironment:{
    EnvironmentRecord:{},
    OuterLexicalEnvironmentReference:{}
}
```
EnvironmentalRecord. 자바스크립트 엔진은 유효범위 안의 식별자와 결과값을 바인드해서 환경 레코드에 기록합니다.

OuterLexicalEnvironmentReference. 여기에는 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장됩니다! 따라서 중첩된 함수 안에서 바깥 코드에 정의된 변수를 읽거나 써야 할 때, 자바스크립트 엔진은 외부 렉시컬 환경 참조를 따라 한 단계씩 렉시컬 환경을 거슬러 올라가서 그 변수를 검색합니다.


###환경 레코드의 구성
Environment Record, which is one of the components of Lexical Environment Component is area that saving identifiers and the values of them.

이 EnvironmentRecord는 Declarative Environment Record와 Object Environment Record로 구성되어있으며, 

환경 레코드가 저장하는 값의 유형에 따라 쓰임새가 달라집니다!!

```js
EnvironmentRecord:{
    DeclarativeEnvironmentRecord:{},
    ObjectEnvironmentRecord:{}
}
```
###선언적 환경 레코드(Declarative Environment Record)
Declarative Environment Record는 실제로 함수와 변수, catch문의 식별자와 실행 결과가 저장되는 영역입니다.

###객체 환경 레코드(Object Environment Record)
Object Environment Records는 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 씁니다.
즉, with문의 렉시컬 환경이나 전역 객체처럼 별도의 객체에 저장된 데이터는 그 객체가 가진 키와 값의 쌍을 복사해 오는 것이 아니라 그 객체 전체의 참조를 가져와서 객체 환경 레코드의 bindObject라는 property에 바인드하도록 만들어져 있습니다.


###전역 환경과 전역 객체의 생성

자바스크립트 인터프리터는 시작하자마자 렉시컬 환경 타입의 전역환경(Global Environment)을 생성합니다. 웹 브라우저에 내장된 자바스크립트 인터프리터는 새로운 웹 페이지를 읽어들인 후에 전역환경을 생성합니다. 그리고 전역 객체를 생성한 다음 전역 환경의 객체 환경 레코드에 전역객체의 참조를 대입합니다. 전역 객체에는 전역 프로퍼티 undefined, NaN, Infinity 생성자 Object(),String(),Number(), 전역함수 parseInt(), parseFloat(), isNaN()등, 내장객체 Math,JSON,Reflect 등의 프로퍼티가 있으며, 최상위레벨의 this는 전역객체를 가리킵니다.

```js
//전역 환경
GlobalEnvironment={
    ObjectEnvironment:{
        bindObject:window
    },
    OuterLexicalEnvironmentReference:null
}
//전역 실행 문맥(Context)
ExecutionContext={
    LexicalEnvironment:GlobalEnvironment,
    ThisBinding:window,
}
```

###프로그램의 평가와 전역변수
전역 환경과 전역 객체를 생성한 후에는 자바스크립트 프로그램을 읽어들입니다. 자바스크립트 프로그램을 다 읽어 들인 후에는 프로그램을 평가하며(evaluate), 최상위 레벨에 var 문으로 작성한 전역 변수는 전역환경의 환경레코드(객체환경레코드)의 프로퍼티로 추가됩니다.

```js
//그니까..이 GlobalEnvironment는 말 그대로 전역실행환경인거다.
GlobalEnvironment={
    ObjectEnvironmentRecord:{//환경레코드는 객체환경레코드고..
        bindObject:window//window객체를 bind해서 그 정보들을 가져온다구..! 리소스!
    },
    OuterLexicalEnvironmentReference:null //window니까..상위 context는 null이 맞다.
}
```

자바스크립트 엔진은 전역코드를 평가(evaluate)할 때 최상위 레벨에 var 문으로 작성한 전역변수를 전역환경의 환경레코드(객체환경레코드)에 기록합니다. 그 프로퍼티 이름은 식별자 이름이 되고 프로퍼티 값은 undefined가 됩니다. 함수의 경우에는 최상위 레벨에 작성된 함수 선언문을 함수 객체로 생성해서 전역 환경의 환경레코드(객체환경레코드)에 프로퍼티로 기록합니다. 이처럼 최상위 레벨에 선언된 변수와 함수는 프로그램을 평가할 때 객체 환경 레코드에 기록됩니다. 

```js
var a = {x:1,y:2};
console.log(window.a);

function norm(x){...}
console.log(window.norm);
```

**즉, 전역 변수의 실체는 전역객체의 프로퍼티 또는 전역 객체의 실행 문맥에 들어있는 (객체)환경 레코드의 프로퍼티입니다!**

**마찬가지로 함수 안에 선언된 지역 변수와 중첩 함수의 참조 또한 그 함수가 속한 실행 환경의 환경 레코드(선언적 환경 레코드)의 프로퍼티입니다.**

이처럼 자바스크립트의 모든 변수를 객체의 프로퍼티로 간주하면 쉽게 이해할 수 있습니다.

앞에서 이야기한 것처럼 최상위 레벨에 선언된 변수와 함수는 프로그램을 평가하는 시점에 환경레코드에 추가됩니다. 최상위 레벨에 선언된 함수와 변수는 프로그램을 평가하는 단계에 이미 객체 환경 레코드에 추가된 상태이기 때문에 코드의 어느 위치에 작성해도 전체 프로그램이 참조할 수 있습니다. 이것이 3.1절과 4.2절에서 설명한 최상위 코드의 변수 선언문과 함수 선언문의 '끌어올림'이라는 현상의 실체입니다.

또한 var문과 함수 선언문으로 선언한 전역변수는 [[Configuable]]속성이 false로 설정되어 있어서 delete연산자로 삭제할 수 없습니다.(이 [[Configuable]]은 스펙에 정의된 명칭이며 자바스크립트에는 configurable이라는 이름으로 참조할 수 있습니다.)

```js
var a={x:1,y:2};
console.log(Object.getOwnPropertyDescriptor(window,'a'));
delete a;
console.log(a);
```

하지만 var문을 사용하지 않고 변수를 선언해서 값을 할당하면 프로그램을 실행하는 도중에 디스 바인딩 컴포넌트가 가리키는 객체의 프로퍼티로 추가됩니다. 전역 객체의 디스 바인딩 컴포넌트는 전역 객체를 가리키므로 결국 전역 객체의 프로퍼티가 되는 것 입니다. 또한 [[Configuable]]속성도 true로 설정됩니다. 따라서 이 경우에는 delete 연산자로 삭제할 수 있습니다.

```js
a={x:1,y:2};
console.log(Object.getOwnPropertyDescriptor(window,'a'));
delete a;
console.log(a);
```

###프로그램 실행과 실행 문맥

프로그램이 평가(Evaluate)된 다음에는 프로그램이 실행(Execution)되며, 프로그램은 실행문맥(Execution Context) 안에서 실행됩니다. 앞에서 설명했듯, 실행 문맥은 실행 가능한 코드(Executable Code - 전역코드, eval코드, 함수코드)별로 생성됩니다.

실행 문맥은 스택(Stack)이라는 구조로 관리됩니다! 스택이란 일종의 자료구조로 데이터를 아래에서부터 쌓아 올려서 마지막으로 추가한 데이터를 먼저 꺼내는 '후입선출(LIFO, Last In First Out)'방식으로 관리됩니다. 스택의 가장 윗부분에 데이터를 쌓는 행위를 push라고 하고, 스택의 가장 윗부분에서 데이터를 빼내는 행위를 pop이라고 합니다.

실행 문맥은 프로그램 실행 중에 스택에 push되어 실행됩니다. 가장 먼저 실행하는 코드는 전역코드이며, 이 때문에 스택의 맨 아랫부분에는 항상 전역 코드를 실행하기 위한 실행 문맥을 스택에 push합니다. 그리고 그 함수의 작업을 끝내고 함수를 호출한 부분으로 제어권이 돌아오면 스택에서 pop합니다. 이 때 실행하는 함수가 특정 함수의 내부에 정의된 중첩 함수라면 중첩 함수의 실행 문맥을 새로 만들어서 스택에 push합니다. **중첩 함수의 실행 문맥이 외부 함수의 실행 문맥 안에 중첩되지 않는다는 점을 꼭 기억하기 바랍니다.**

마찬가지로, 함수 안에 있는 코드를 실행하는 도중에 다른 함수를 호출하면 그 함수의 실행 문맥도 스택에 push합니다. 이 방식은 중첩 함수를 호출했을 경우와 함수를 재귀적으로 호출한 경우에도 똑같이 적용됩니다.

재귀호출한 함수는 분명 호출한 함수와 같은 함수입니다. 하지만 전혀 다른 함수로서 스택에 push됩니다. 이처럼 함수의 실행 문맥은 호출될 때마다 스택에 push됩니다. 그리고 return 문이 실행되어 제어권이 호출한 코드로 돌아가면 스택에서 pop됩니다. 이러한 이유로 **실행 문맥 스택**을 **호출스택**이라는 이름으로 부릅니다. 

###자바스크립트는 싱글스레드(Single Thread)
스레드란 프로그램의 처리 흐름입니다. 싱글 스레드 방식은 프로그램 한 개의 처리 흐름으로 프로그램을 **순차적으로** 실행하는 방식입니다. 멀티스레드 방식은 프로그램 여러 개의 처리 흐름으로 동시에 작업을 여러 개 병렬적으로 실행하는 방식입니다.

자바스크립트에서는 작업을 싱글 스레드로 처리합니다. 호출 스택에 쌓인 실행 문맥(함수 또는 코드)를 위에서부터 아래로 차례차례 실행해 나갑니다. 그리고 실행 문맥 하나의 작업이 끝나면 pop을 하고 바로 아래에 있는 실행 문맥(Execution Context, EC)을 실행합니다. 즉, 실행 문맥 단위의 작업을 차례대로 실행하므로 실행문맥(함수나 코드) 하나의 작업이 끝날때까지 또 다른 실행 문맥의 작업을 실행하지 않습니다!

이벤트 처리와 같은 비동기 처리도 똑같은 방식으로 실행합니다. 실행할 준비를 마친 이벤트 처리기 함수와 비동기 처리는 실행하기에 앞서 이벤트 큐에 대기 행렬을 만듭니다. 그리고 현재 실행중인 함수의 작업이 끝나면 대기 행렬에서 실행을 기다리는 첫 번째 실행 문맥(함수 또는 코드) 부터 차례대로 호출 스택에 push해서 실행해나갑니다.

이 때 웹 브라우저의 API인 Web Workers를 사용하면 특정 작업을 백그라운드에 있는 다른 스레드에서 실행할 수 있습니다. 즉, 멀티스레드 처리를 할 수 있습니다. Web Workers는 19장에서 배웁니다.

이 때 웹 브라우저의 API인 Web Workers를 사용하면 특정 작업을 백그라운드에 있는 다른 스레드에서 실행할 수 있습니다. 즉, 멀티스레드 처리를 사용할 수 있습니다. Web Workers는 19장에서 배웁니다 -

***대기행렬? - 대기 행렬은 은행의 ATM에 늘어선 고객의 행렬처럼, 어떤 서비스를 받기 위해 순서대로 한 줄로 줄을 서서 기다리는 행렬을 말합니다. 대기 행렬에선ㄴ 앞에서 진행 중인 작업이 끝나면 그 작업을 대기열에서 삭제하고 그 다음 작업을 시작합니다. 대기 행렬은 먼저 추가한 작업을 먼저 꺼내는 선입선출(FIFO, First In First Out)행렬 이라는 이름으로도 불립니다.

### 환경 레코드와 지역 변수

함수를 호출하면 현재 실행중인 코드의 작업을 일시적으로 멈추고 실행 문맥(Execution Context)영역을 생성합니다. 그리고 프로그램의 실행 흐름이 그 실행 문맥으로 이동합니다. 다음으로 그 함수의 실행 문맥이 호출 스택에 push되고 실행 문맥 안에 렉시컬 환경 컴포넌트를 생성합니다.

이 렉시컬 환경 컴포넌트는 환경 레코드를 가지고 있으며, 환경 레코드 안에 그 함수 안에서 선언된 중첩 함수의 참조와 변수를 기록합니다. 즉, 함수 안팎의 환경(Environment)를 기록합니다. 이 환경 레코드는 사용자가 읽거나 쓸 수 없으며 다음과 같은 정보를 기록하는 용도로 사용됩니다.

- 함수의 인자
- 함수 안에서 선언된 중첩 함수의 참조
- 함수 안에서 var로 선언한 지역 변수





## 6. 클로저
## 7. 이름 공간
## 8. 객체로서의 함수
## 9. 고차 함수
## 10. 콜백 함수
## 11. ECMAScript 6부터 추가된 함수의 기능






