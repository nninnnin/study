***Redux***

- redux의 state(상태)는 component의 state와는 다른 개념이다. 리덕스의 스테이트는 리덕스 안에 있는 데이터를 의미하는 것

- Redux의 사용 목적 
  - 불필요한 Props의 전달
  - 데이터에 직접 접근 (**Redux Store**)


Flux Architecture
- 페이스북에서 제시된 개념
- 단방향 데이터 바인딩
- 한 방향으로만 데이터가 흐르도록 만들어진 구조
- 이 아키텍처를 구현한 라이브러리가 Redux이다.(MobX도 있음)

Redux를 사용하면 여태까지 각 컴포넌트의 state에 저장해오던 데이터들을 Redux의 store에 저장하여 각 컴포넌트들이 이에 직접 접근해 데이터를 사용할 수 있도록 한다.


state -> event -> actions -> dispatcher(파견자)

리액트가 리덕스에게 action 을 dispatch하면
redux가 이 action을 까보고 정보를 확인하고 이에 맞는 처리를 수행

이에 기반해서 redux가 새로운 state를 만들어주고, 이 state에 맞도록 react가 다시 렌더링한다.

잘 모르겠다..lifecycle API와는 무슨관계인지?

가장 최상위만 Redux와 연결하고, 나머지 애들은, 단순히 데이터 넘기는 애들은 prop으로 넘겨서 활용하자 Presentational component와 Container Component로 나뉜다.


- action을 비동기적인 코드로 바꾸어주는 것이 reduc thunk라는 라이브러리이다

---
여기서부터는 벨로퍼트 글

*리덕스를 왜 쓸까? 그리고 리덕스를 편하게 사용하기 위한 발악*


- 리덕스는 왜 쓰는가?
리액트에서 애플리케이션을 만들떄 보통 하나의 루트 컴포넌트 (App.js)에서 상태를 관리한다.

리액트 프로젝트에서는 대부분의 작업을 할 때 부모 컴포넌트가 중간자 역할을 한다.

컴포넌트끼리 직접 소통하는 방법이 있기는 하지만, 코드가 굉장히 꼬이기 때문에 권장되지 않는다.(ref를 사용)

App에서는 인풋의 값인 input값과 이를 변경하는 onChange함수와 새 아이템을 생성하는 onCreate함수를 props로 Form에게 전달해준다. 

Form은 해당 함수와 값을 받아서 화면에 보여주고, 변경 이벤트가 일어나면 부모에게서 받은 onChange를 호출하여 App이 지닌 input값을 업데이트한다.

그렇게 인풋값을 수정하여 추가 버튼을 누르면, onCreate를 호출하여 todos 배열을 업데이트한다.

todos배열이 업데이트 되면, 해당 배열이 TodoItemLIst컴포넌트한테 전달이 되어 화면에 렌더링

이런식으로 App컴포넌트를 거쳐서 건너건너 필요한 값을 업데이트하고, 리렌더링하는 방식으로 프로젝트가 개발.

하지만 앱의 규모가 커진다면..?

- 리덕스를 사용하면 상태관리를 **컴포넌트 바깥**에서 한다

리덕스를 사용하면 상태값을 컴포넌트에 종속시키지 않고 상태관리를 컴포넌트의 바깥에서 관리할 수 있게 된다.

이 컴포넌트의 바깥은 바로 리덕스의 Store를 의미한다.

Store에는 프로젝트의 상태에 관한 데이터들이 담겨있다.

- 컴포넌트의 스토어 구독 : subscribe(listener)
component는 스토어를 subscribe하고 Redux store는 subscribe하는 컴포넌트에게 값이 변경되면 알림을.

*구독을 하는 과정에서, 특정 함수가 스토어에게 전달이 되고, 이후에 스토어의 상태값에 변동이 생긴다면 전달받았던 함수를 호출하게 된다!*

아마도 이 '특정 함수' 가 subscribe의 인자로 들어간 listener겠지?

- Store에게 상태변경하라고 알려주기 : dispatch(action)
'스토어야 상태 업데이트 해줘, 업데이트 할때는 내가 준 데이터 참고하고!'

예를 들어 하나의 컴포넌트에 이벤트가 발생해서 상태변화를 할 일이 생겼다고 치자. 버튼을 눌러서 해당 버튼의 포켓몬API 데이터를 가져와야 한다고하면, 이 때 dispatch라는 함수를 통해 action을 Store에게 던져준다. 

액션은 상태에 변화를 일으킬 때 참조할 수 있는 객체이며, 필수적으로 type이라는 값을 가지고 있어야 한다.

예를들어 `{type: INCREMENT}` 라는 객체를 전달 받게 된다면, 리덕스 스토어는 '상태에 값을 더해야 하는구나!' 하고 액션을 참조하게 된다.

추가적으로, 상태값에 2를 더해야 한다면, 이러한 액션 객체를 만들게 된다.

`{type: 'INCREMENT', diff: 2}`

그러면, 나중에 이 diff값을 참고해서 기존 값에 2를 더하게 되며, type을 제외한 값은 선택적인 값이라는 것을 알아두자.


- 리듀서(reducer)를 통하여 상태를 변화시키기

액션 객체를 전달받으면, 전달받은 액션의 타입에 따라 어떻게 상태를 업데이트해야 할지 정의를 해주어야 할 것이다. 이러한 업데이트 로직을 정의하는 함수를 리듀서(reducer)라고 부른다. 

이 함수는 나중에 우리가 *직접 구현하게 된다*! 

예를 들어 type이 INCREMENT라는 액션이 들어오면 숫자를 더해주고, DECREMENT라는 액션이 들어오면 숫자를 감소시키도록 만드는 그런 작업을 여기에 함수로서 정의해 주면 될 것이다.

리듀서 함수는 두가지의 파라미터를 받는다.

1. state: 현재 상태
2. action: 액션 객체

그리고 이 두가지 파라미터를 참조하여, 새로운 상태 객체를 만들어서 이를 반환하게 된다.

- 상태에 변화가 생기면, 구독하고 있던 컴포넌트에게 알림
상태에 변화가 생기면, 이전에 컴포넌트가 스토어에게 구독할 때 전달해주었던 함수 listener가 호출된다. 이를 통해 컴포넌트는 새로운 상태를 받게 되고, 이에 따라 컴포넌트는 리렌더링을 수행하게 된다.

- 정리
리덕스를 사용하면 스토어를 사용하여 상태를 컴포넌트의 바깥에 두고, 스토어를 매개로 상태를 업데이트하거나 새로운 상태를 각각의 컴포넌트가 전달받는다. 따라서, 여러 컴포넌트를 거쳐서 받아올 필요 없이 아무리 깊숙한 컴포넌트에 있다 하더라도 원하는 상태값을 골라서 props를 편하게 받아올 수 있게 된다.


- 리액트 없이 쓰는 리덕스
리덕스는 리액트에 종속되는 그런 라이브러리가 아니다.


- 아아주 간단한 리덕스 예제를 한번!! 만들어봅시다

